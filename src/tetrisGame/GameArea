
package tetrisGame;

import TetrisBlocks.*;
import java.awt.Color;
import java.awt.Graphics;
import java.util.Random;
import javax.swing.JPanel;

public class GameArea extends JPanel {
    
    private int gridRows;
    private int gridColumns;
    private int gridCellSize;
    private Color[][] background;
    
    private TetrisBlock block;
    private TetrisBlock[] blocks;
    
    private int lastBlock=7;
    private int currentBlock;
    
    public GameArea(JPanel placeholder,int columns){
        //placeholder.setVisible(false);
        this.setBounds(placeholder.getBounds());
        this.setBackground(placeholder.getBackground());
        this.setBorder(placeholder.getBorder());
        gridColumns=columns;
        gridCellSize=this.getBounds().width/gridColumns;
        gridRows=this.getBounds().height/gridCellSize;
        
        blocks=new TetrisBlock[]{new S_Shape(),
                                 new L_Shape(),
                                 new T_Shape(),
                                 new Z_Shape(),
                                 new O_Shape(),
                                 new J_Shape(),
                                 new I_Shape(),
                                 new Dot_Shape()};
    }
    
    public void initBackgroundArray(){       
        background= new Color[gridRows][gridColumns];
    }
    
    @Override
    public void paintComponent(Graphics g){
        super.paintComponent(g);
        drawBackground(g);
        drawBlock(g);
        
    }
    
    private void drawBlock(Graphics g){
        int h= block.getHeight();
        int w= block.getWidth();
        Color c= block.getColor();
        int[][] shape= block.getShape();
        for(int row=0;row<h;row++){
            for(int col=0;col<w;col++){
                if(shape[row][col]== 1)
                {
                    int x=(block.getX()+col)*gridCellSize;
                    int y=(block.getY()+row)*gridCellSize;
                    drawGridSquare(g,c,x,y);
                }
            }
        }
    }
    
    public void spawnBlock(){
        block= blocks[probability()];
        block.spawn(gridColumns);
    }
    
    public int probability(){
        Random r=new Random();
        while(true){
            int randNum=r.nextInt(100);
            if(randNum<20){
                currentBlock=0;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum<40){
                currentBlock=1;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum<55){
                currentBlock=2;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum<70){
                currentBlock=3;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum<82){
                currentBlock=4;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum<92){
                currentBlock=5;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum<99){
                currentBlock=6;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
            if(randNum==99){
                currentBlock=7;
                if(lastBlock==currentBlock) continue;
                lastBlock=currentBlock;
                return currentBlock;
            }
        }
    }
    
    public boolean movBlockDown(){
        if(!checkBottom()){
            return false;
        } 
        block.movDown();
        repaint();
        return true;
    }
    
    public void movBlockRight(){
        if(block==null) return;
        if(!checkRight()) return;
        block.movRight();
        repaint();
    }
    
    public void movBlockLeft(){
        if(block==null) return;
        if (!checkLeft()) return;
        block.movLeft();
        repaint();
    }
    
    public void dropBlock(){
        if(block==null) return;
        int i=0;
        while( checkBottom()&&i<4){
            block.movDown();
            i++;
        }
        repaint();
    }
    
    public void rotateBlock(){
        if(block==null) return;
        block.rotate();
        if(block.getLeftEdge()<0) block.setX(0);
        if(block.getRightEdge()>=gridColumns) block.setX(gridColumns-block.getWidth());
        if(block.getBottomEdge()>gridRows) block.setY(gridRows-block.getHeight());
        repaint();
    }
   
    
    private boolean checkBottom(){
        if(block.getBottomEdge()==gridRows) return false;
        
        int[][]shape = block.getShape();
        int w=block.getWidth();
        int h=block.getHeight();
        
        for(int col=0;col<w;col++){
            for(int row=h-1;row>=0;row--){
                if(shape[row][col]!=0){
                    int x=col+block.getX();
                    int y=row+block.getY()+1;
                    if(y<0) break;
                    if(background[y][x]!=null) return false;
                    break;
                }
            }
        }
        
        return true;
    }
    
    private boolean checkLeft(){
        if(block.getLeftEdge()==0) return false;
        
        int[][]shape = block.getShape();
        int w=block.getWidth();
        int h=block.getHeight();
        
        for(int row=0;row<h;row++){
            for(int col=0;col<w;col++){
                if(shape[row][col]!=0){
                    int x=col+block.getX()-1;
                    int y=row+block.getY();
                    if(y<0) break;
                    if(background[y][x]!=null) return false;
                    break;
                }
            }
        }
        
        return true;
    }
    
    private boolean checkRight(){
        if(block.getRightEdge()==gridColumns) return false;
        
        int[][]shape = block.getShape();
        int w=block.getWidth();
        int h=block.getHeight();
        
        for(int row=0;row<h;row++){
            for(int col=w-1;col>=0;col--){
                if(shape[row][col]!=0){
                    int x=col+block.getX()+1;
                    int y=row+block.getY();
                    if(y<0) break;
                    if(background[y][x]!=null) return false;
                    break;
                }
            }
        }
        
        return true;
    }
    
    private void drawBackground(Graphics g){
        Color color;
        for(int r=0;r<gridRows;r++){
            for(int c=0;c<gridColumns;c++){
                color=background[r][c];
                if(color!=null){
                    int x=c*gridCellSize;
                    int y=r*gridCellSize;
                    
                    drawGridSquare(g,color,x,y);
                }
            }
        }
    }
    
    private void drawGridSquare(Graphics g,Color color,int x, int y){
        g.setColor(color);
        g.fillRect(x,y, gridCellSize, gridCellSize);
        g.setColor(Color.BLACK);
        g.drawRect(x,y,gridCellSize,gridCellSize);
    }
    
    public void movBlockToBackground(){
        int shape[][]= block.getShape();
        int h= block.getHeight();
        int w= block.getWidth();
        
        int xPos=block.getX();
        int yPos=block.getY();
        
        Color color= block.getColor();
        
        for(int r=0;r<h;r++){
            for(int c=0;c<w;c++){
                if (shape[r][c]==1){
                    background[r+yPos][c+xPos]=color;
                }
            }
        }
    }
    
    public double clearLines(){
        boolean lineFilled;
        double linesCleared=0;
        
        if(currentBlock==7){
            boolean lowerRowCleared=false;
            boolean upperRowCleared=false;
            clearLine(block.getY());
            if(block.getY()!=gridRows-1){clearLine(block.getY()+1);lowerRowCleared=true;}
            if(block.getY()!=0){clearLine(block.getY()-1);upperRowCleared=true;}
            
            if(lowerRowCleared&&upperRowCleared){
                shiftDown(block.getY()+1);
                shiftDown(block.getY()+1);
                shiftDown(block.getY()+1);
            }
            if(!upperRowCleared){
                shiftDown(block.getY()+1);
                shiftDown(block.getY()+1);
            }
            if(!lowerRowCleared){
                shiftDown(gridRows-1);
                shiftDown(gridRows-1);
            }
            
            TetrisGame.playClearLines();
            
            return 5.1;
        }
        
        for(int r=gridRows-1;r>=0;r--){
            lineFilled=true;
            for(int c=0;c<gridColumns;c++){
                if(background[r][c]==null){
                    lineFilled=false;
                    break;
                }
            }
            
            if(lineFilled){
                linesCleared++;
                clearLine(r);
                shiftDown(r);
                clearLine(0);
                r++;
                repaint();
            }
        }
        if(linesCleared==2) return (linesCleared*1.25);
        if(linesCleared==3) return (linesCleared*1.5);
        if(linesCleared>3) return (linesCleared*2);
        
        if(linesCleared>0)TetrisGame.playClearLines();
        
        return linesCleared;
    }
    
    public void clearLine(int r){
        for(int i=0;i<gridColumns;i++){
            background[r][i]=null;
        }
    }
    
    public void shiftDown(int r){
        for(int row=r;row>0;row--){
            for(int col=0;col<gridColumns;col++){
                background[row][col]=background[row-1][col];
            }
        }
    }
    
    public boolean isBlockOutOFBound(){
        if(block.getY()<0){
            block=null;
            return true;
        }
        
        return false;
    }
}
